
#originally developerd on bash, now I run them on zsh and they seem to work

# waits for the given pid to finish
waitfor() {
    while ( ps $1 >/dev/null ); do sleep 1; done
}

# macos: unmounts a volume by name (note usb drives don't seem to power down)
unmountvol() {
    if [[ -z "$1" ]]; then
        echo 'usage: unmountvol <volumename>'
    else
        diskutil unmount `df |egrep "/Volumes/\Q$1\E" |cut -d\  -f 1`
    fi
}

# macos: sends pasteboard (pb) contents to the clipboard of the target osx machine
pbto() {
    pbpaste | ssh "$1" pbcopy
}

# macos: receives pasteboard (pb) contents from the clipboard of the target osx machine
pbfrom() {
    ssh "$1" pbpaste | pbcopy
}

# macos: do something to the contents of the clipboard
pbdo() {
    cmd=$@
    pbpaste | eval $cmd  | pbcopy
}

# filter to normalise track descriptors to make suitable for search
# tracks typically have a form like this:
#   Track Name (Foobar Mix) - Artist Name
# the transformed result would be:
#   Track Name Foobar Mix Artist Name
trackclean() {
    perl -pe's/[\W\s]+/ /g and s/(^\s+|\s+$)//' 
}

# like which but works with functions and aliases too
# i've since been informed about the builtin "type" which should 
# possibly be preferred 
wot() {
    local it=$1
    declare -f $it || (e=`alias $it 2>&1` && echo $e) || which $it
}

#edit profile files
epfl() {
    if ( "$SHELL" == "zsh" ); then
        $EDITOR ~/.zshrc
    elif ( "$SHELL" == "bash" ); then
        $EDITOR -o ~/.bash_profile ~/.bashrc
    else
        echo Do not know how to edit profile for shell $SHELL
    fi
}

#command line media player, good for console streaming radio
cvlc() {
    /Applications/VLC.app/Contents/MacOS/VLC -I rc --play-and-exit $@
}

# cat which - print the source of an executable on the path by name
cw() {
    cat `which "$1"`
}

# ps grep - grep for a running process but not "grep"
# see also psgrep
psg() {
    ps aux |grep $@ |grep -v grep
    echo apparently use psgrep bro
}

cleanMavenSnapshots() {
    local days=${1:-30}
    find $HOME/.m2/repository -name '*SNAPSHOT*' ! -atime -${days}d -print -delete
    echo "$? purged old unused (${days} days) snapshots from maven repo"
}

# removes filesystem stuff generated by macos (e.g. spotlight), useful for removable volumes 
cleanMacPoo() {
    if [[ $# != 1 ]]; then 
        echo 'usage: cleanMacPoo <dir>'
    else
        echo cleaning from $1 :
        find $1 -name '._*' -o -name '.Spotlight-*' -o -name '.fseventsd' -print -delete
    fi
}

#diskfull root filesystem percentage only
dfull() {
    df / | tail -n 1 | perl -ne '/((\S+\s+){5})(\S+\s+)/ && print"$2\n"'
}  

# disk free root fs human readable
dfree() {
     df -h / | tail -1 | perl -ne '/(\S+\s+){3}(\S+)/ && print"$2\n"'
}

#sorted size totals in megs of given dir tree (or current)
megs() {
    du -m "${1:-.}" |sort -n
}

#sorted size totals in gigs of given dir tree (or current)
gigs() {
    du -g "${1:-.}" |sort -n
}

#maven clean install (skipping tests) [..] # cowbell broken, hopefully don't need more cowbell
mcis() {
    mvn clean install -DskipTests $@
    cowbell
}

# lists processes listening on tcp ports
listeners() {
    # TODO linux equivalent
    lsof -i -P -n -sTCP:LISTEN $@
}

# starts an http server with docroot in the current directory
server () { 
    local host=`hostname`;
    local port="${1:-8888}";
    ( sleep 1 && open "http://${host}:${port}/" ) & python3 -m http.server  "$port"
    # this was the python2 way
    #( sleep 1 && open "http://${host}:${port}/" ) & python -m SimpleHTTPServer "$port"
}

# adds colour
man() {
    env LESS_TERMCAP_mb=$'\E[01;31m' \
    LESS_TERMCAP_md=$'\E[01;38;5;74m' \
    LESS_TERMCAP_me=$'\E[0m' \
    LESS_TERMCAP_se=$'\E[0m' \
    LESS_TERMCAP_so=$'\E[38;5;148m' \
    LESS_TERMCAP_ue=$'\E[0m' \
    LESS_TERMCAP_us=$'\E[04;38;5;146m' \
    man "$@"
}

# which processes are consuming most cpu?
pigs() {
    ps auxrww | head -n 5
}

# offline maven
mvno() {
    mvn -o $@
}

# automated maven release 
mrelease() {
    mvn -B release:prepare && mvn release:perform
}

# print the manifest of the given jar file
catmf() {
    unzip -c $1 META-INF/MANIFEST.MF
}

# how slammed am i?
# compact 'up' with sparkline output (requires spark)
# show recent load averages as comes from uptime as a sparkline
# shows sparkline if you have the spark program
ups() {
    l=`uptime | perl -p -e 's/.*averages: (.*)/$1/'`
    which spark >>/dev/null && echo $l |spark || echo $l
}

grepos() {
    for i in *; do find "$i" -name '.git' -maxdepth 6 -type d | perl -pe 's/(.*)\.git/$1/'; done
}

# do a git pull on repos under the current directory tree unless they're already fresh runs in 3 parallel threads
gpullr() {
    # TODO only do a pull if has remote via 0 exit from: git -C "$0" remote -v
    grepos |xargs -n 1 -P 3 -I % bash -c \
        'GIT_TERMINAL_PROMPT=0 git -C "$0" pull 2>&1|perl -e "while(<STDIN>){chomp and print \"$0 \$_\n\";}"' %
}

# make a dir (if it doesn't already exist) and cd into it
mcd() {
    mkdir -p "$1" && cd "$1"
}

# list make targets
maketargets() {
    make -qp|perl -ne's/^(\w[^#\s.\t:]+):/$1/ && print "$1\n"'|sort -u
}

# show terminal dimensions
dim() {
    echo $COLUMNS x $LINES
}

reloadchristosh() {
    source "$CHRISTOSH_HOME/sourceme.sh"
}

# report tmux sessions, useful to run on login on remote boxes
report_tmux() {
    which tmux >/dev/null && tmux has-session >/dev/null 2>&1 && ( echo tmux sessions: ; tmux list-sessions )
}

# show latest clonewatch clones
cw_latest() {
    # TODO move to clonewatch repo
    ls -tr $HOME/src/other/github.com \
        | tail \
        | xargs -I % find "%" -depth 1 -newer "%/.." -not -regex ".*/\..*"

}

bro() {
    brew outdated | xargs brew desc
}

# VPNs: 
# AWS Sydney 
# AWS VPN
function vpn-connect {
/usr/bin/env osascript <<-EOF
tell application "System Events"
        tell current location of network preferences
                set VPN to service "AWS Sydney" 
                if exists VPN then connect VPN
                repeat while (current configuration of VPN is not connected)
                    delay 1
                end repeat
        end tell
end tell
EOF
}

function vpn-disconnect {
/usr/bin/env osascript <<-EOF
tell application "System Events"
        tell current location of network preferences
                set VPN to service "AWS Sydney" 
                if exists VPN then disconnect VPN
        end tell
end tell
return
EOF
}
alias vpnu='vpn-connect'
alias vpnd='vpn-disconnect'
alias remotes='git remote -v'

# vim ft=zsh
